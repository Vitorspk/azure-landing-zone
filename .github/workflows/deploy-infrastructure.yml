name: Deploy Infrastructure

on:
  workflow_dispatch:
    inputs:
      module:
        description: 'Module to deploy'
        required: true
        type: choice
        options:
          - 'all'
          - '00-iam'
          - '01-networking'
          - '02-kubernetes'
      action:
        description: 'Action'
        required: true
        type: choice
        options:
          - 'plan'
          - 'apply'
      clusters:
        description: 'Which clusters to deploy (for kubernetes module only)'
        required: false
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'dev'
          - 'stg'
          - 'prd'
          - 'sdx'
          - 'dev,stg'
          - 'dev,stg,prd'
      import_existing:
        description: 'Import existing resources before apply'
        required: false
        type: boolean
        default: true

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy Module
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          IMPORT_EXISTING: ${{ github.event.inputs.import_existing }}
        run: |
          # Function to safely import a resource
          safe_import() {
            local resource_address=$1
            local resource_id=$2
            
            # Check if resource is already in state
            if terraform state show "$resource_address" &>/dev/null; then
              echo "    ‚úì Already in state"
              return 0
            fi
            
            # Try to import
            if terraform import "$resource_address" "$resource_id" 2>&1 | grep -q "Successfully imported"; then
              echo "    ‚úì Imported successfully"
              return 0
            elif terraform state show "$resource_address" &>/dev/null; then
              echo "    ‚úì Now in state"
              return 0
            else
              echo "    ‚ö† Import failed (resource may not exist in Azure)"
              return 0  # Don't fail the workflow
            fi
          }
          
          # Function to import existing resources for a module
          import_existing_resources() {
            local module=$1
            echo "üîÑ Checking for existing resources to import..."
            
            case "$module" in
              00-iam)
                # Resource Group
                if az group show --name rg-network &>/dev/null; then
                  echo "  ‚Üí Resource Group: rg-network"
                  safe_import "azurerm_resource_group.iam" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network"
                fi
                
                # Managed Identities - Per Environment
                for env in dev stg prd sdx; do
                  if az identity show --name mi-aks-$env --resource-group rg-network &>/dev/null; then
                    echo "  ‚Üí Managed Identity: mi-aks-$env"
                    safe_import "azurerm_user_assigned_identity.aks_env[\\\"$env\\\"]" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.ManagedIdentity/userAssignedIdentities/mi-aks-$env"
                  fi
                done
                
                # Shared Identity
                if az identity show --name mi-aks-cluster-shared --resource-group rg-network &>/dev/null; then
                  echo "  ‚Üí Managed Identity: mi-aks-cluster-shared"
                  safe_import "azurerm_user_assigned_identity.aks[0]" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.ManagedIdentity/userAssignedIdentities/mi-aks-cluster-shared"
                fi
                ;;
                
              01-networking)
                # Virtual Network
                if az network vnet show --name vnet-shared-network --resource-group rg-network &>/dev/null; then
                  echo "  ‚Üí Virtual Network: vnet-shared-network"
                  safe_import "azurerm_virtual_network.shared" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.Network/virtualNetworks/vnet-shared-network"
                fi
                
                # Subnets
                for subnet_name in dev-subnet stg-subnet prd-subnet sdx-subnet; do
                  env=$(echo $subnet_name | cut -d'-' -f1)
                  if az network vnet subnet show --vnet-name vnet-shared-network --name $subnet_name --resource-group rg-network &>/dev/null; then
                    echo "  ‚Üí Subnet: $subnet_name"
                    safe_import "azurerm_subnet.subnets[\\\"$env\\\"]" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.Network/virtualNetworks/vnet-shared-network/subnets/$subnet_name"
                  fi
                done
                
                # NSG
                if az network nsg show --name nsg-allow-ssh --resource-group rg-network &>/dev/null; then
                  echo "  ‚Üí NSG: nsg-allow-ssh"
                  safe_import "azurerm_network_security_group.allow_ssh" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.Network/networkSecurityGroups/nsg-allow-ssh"
                fi
                
                # Public IP
                if az network public-ip show --name pip-nat-gateway-shared --resource-group rg-network &>/dev/null; then
                  echo "  ‚Üí Public IP: pip-nat-gateway-shared"
                  safe_import "azurerm_public_ip.nat_gateway" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.Network/publicIPAddresses/pip-nat-gateway-shared"
                fi
                
                # NAT Gateway
                if az network nat gateway show --name nat-gateway-shared --resource-group rg-network &>/dev/null; then
                  echo "  ‚Üí NAT Gateway: nat-gateway-shared"
                  safe_import "azurerm_nat_gateway.shared" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.Network/natGateways/nat-gateway-shared"
                fi
                ;;
                
              02-kubernetes)
                # AKS Clusters
                for cluster_name in aks-dev aks-stg aks-prd aks-sdx; do
                  env=$(echo $cluster_name | cut -d'-' -f2)
                  if az aks show --name $cluster_name --resource-group rg-network &>/dev/null; then
                    echo "  ‚Üí AKS Cluster: $cluster_name"
                    safe_import "module.aks_clusters[\\\"$env\\\"].azurerm_kubernetes_cluster.aks" "/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/rg-network/providers/Microsoft.ContainerService/managedClusters/$cluster_name"
                  fi
                done
                ;;
            esac
            
            echo "‚úÖ Import process completed"
          }
          
          # Main deployment logic
          if [ "${{ github.event.inputs.module }}" == "all" ]; then
            # Deploy all modules sequentially
            for module in 00-iam 01-networking 02-kubernetes; do
              echo "========================================"
              echo "Deploying module: $module"
              echo "========================================"
              cd terraform/$module
              terraform init
              
              # Import existing resources if enabled
              if [ "$IMPORT_EXISTING" == "true" ]; then
                import_existing_resources $module
              fi
              
              # Execute terraform command
              if [ "$module" == "02-kubernetes" ]; then
                echo "Clusters to deploy: ${{ github.event.inputs.clusters }}"
                if [ "${{ github.event.inputs.action }}" == "apply" ]; then
                  terraform apply -auto-approve -var="deploy_clusters=${{ github.event.inputs.clusters }}"
                else
                  terraform plan -var="deploy_clusters=${{ github.event.inputs.clusters }}"
                fi
              else
                if [ "${{ github.event.inputs.action }}" == "apply" ]; then
                  terraform apply -auto-approve
                else
                  terraform plan
                fi
              fi
              
              cd ../..
            done
          else
            # Deploy single module
            echo "========================================"
            echo "Deploying module: ${{ github.event.inputs.module }}"
            echo "========================================"
            cd terraform/${{ github.event.inputs.module }}
            terraform init
            
            # Import existing resources if enabled
            if [ "$IMPORT_EXISTING" == "true" ]; then
              cd ../..
              import_existing_resources ${{ github.event.inputs.module }}
              cd terraform/${{ github.event.inputs.module }}
            fi
            
            # Execute terraform command
            if [ "${{ github.event.inputs.module }}" == "02-kubernetes" ]; then
              echo "Clusters to deploy: ${{ github.event.inputs.clusters }}"
              if [ "${{ github.event.inputs.action }}" == "apply" ]; then
                terraform apply -auto-approve -var="deploy_clusters=${{ github.event.inputs.clusters }}"
              else
                terraform plan -var="deploy_clusters=${{ github.event.inputs.clusters }}"
              fi
            else
              if [ "${{ github.event.inputs.action }}" == "apply" ]; then
                terraform apply -auto-approve
              else
                terraform plan
              fi
            fi
          fi
      
      - name: Deployment Summary
        if: always()
        run: |
          echo ""
          echo "=========================================="
          echo "üìä Deployment Summary"
          echo "=========================================="
          echo ""
          echo "Module: ${{ github.event.inputs.module }}"
          echo "Action: ${{ github.event.inputs.action }}"
          echo "Clusters: ${{ github.event.inputs.clusters }}"
          echo "Import Existing: ${{ github.event.inputs.import_existing }}"
          echo ""
          
          if [ "${{ job.status }}" == "success" ]; then
            if [ "${{ github.event.inputs.action }}" == "plan" ]; then
              echo "‚úÖ Planning completed successfully!"
              echo ""
              echo "Review the plan above. If OK:"
              echo "  Run workflow again with action: apply"
            else
              echo "‚úÖ Infrastructure deployment completed successfully!"
              echo ""
              echo "Resources are now live in Azure."
              echo ""
              echo "üìù Next Steps:"
              if [ "${{ github.event.inputs.module }}" == "00-iam" ] || [ "${{ github.event.inputs.module }}" == "all" ]; then
                echo "  1. Deploy networking: module=01-networking, action=apply"
              fi
              if [ "${{ github.event.inputs.module }}" == "01-networking" ] || [ "${{ github.event.inputs.module }}" == "all" ]; then
                echo "  2. Deploy kubernetes: module=02-kubernetes, action=apply"
              fi
              if [ "${{ github.event.inputs.module }}" == "02-kubernetes" ] || [ "${{ github.event.inputs.module }}" == "all" ]; then
                echo "  3. Deploy ingress: Use 'deploy-ingress-nginx' workflow"
              fi
            fi
          else
            echo "‚ùå Deployment failed. Check logs above."
            echo ""
            echo "üí° Common issues:"
            echo "  - Check GITHUB_SECRETS.md for correct secrets configuration"
            echo "  - Ensure Service Principal has Owner role"
            echo "  - If resources exist: Delete manually with 'az group delete --name rg-network'"
            echo "  - Or use remote state backend to persist state between runs"
          fi
          echo ""
